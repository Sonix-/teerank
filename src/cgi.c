#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <assert.h>
#include <sys/stat.h>
#include <errno.h>
#include <string.h>
#include <limits.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "io.h"

static const char cache_root[] = "/var/cache/teerank";
static const char db_root[] = "./data";

static char *reason_phrase(int code)
{
	switch (code) {
	case 200: return "OK";
	case 404: return "Not Found";
	case 500: return "Internal Server Error";
	default:  return "";
	}
}

static void error(int code, char *fmt, ...)
{
	va_list ap;

	printf("Content-type: text/html\n");
	printf("Status: %d %s\n\n", code, reason_phrase(code));
	printf("<h1>%d %s</h1>\n", code, reason_phrase(code));

	if (fmt) {
		printf("<pre>");
		va_start(ap, fmt);
		vprintf(fmt, ap);
		va_end(ap);
		printf("</pre>");
		exit(EXIT_FAILURE);
	}
}

static char *extract_string_between(char *start, char *end, const char *str)
{
	static char ret[MAX_NAME_LENGTH];
	size_t len, len_str, len_start, len_end;

	assert(start != NULL);
	assert(end != NULL);
	assert(str != NULL);

	len_start = strlen(start);
	if (memcmp(str, start, len_start))
		return NULL;
	len_end = strlen(end);
	len_str = strlen(str);
	if (len_end > len_str)
		return NULL;
	if (memcmp(str + len_str - len_end, end, len_end))
		return NULL;
	if (len_start + len_end >= len_str)
		return NULL;
	len = len_str - len_start - len_end;
	memcpy(ret, str + len_start, len);

	return ret;
}

enum type { INDEX, PAGES, CLANS };

struct page {
	enum type type;
	char dest[PATH_MAX];
	unsigned ndeps;
	char deps[16][PATH_MAX];
	char *src;
};

static void get_page(const char *path, struct page *page)
{
	char *str;

	assert(page != NULL);
	assert(page != NULL);

	if (!strcmp(path, "/") || !strcmp(path, "/index.html")) {
		page->type = INDEX;
		sprintf(page->dest, "%s/%s", cache_root, "index.html");
		sprintf(page->deps[0], "%s/%s", db_root, "players/");
		page->ndeps = 1;
		page->src = NULL;
	} else if ((str = extract_string_between("/pages/", ".html", path))) {
		page->type = PAGES;
		sprintf(page->dest, "%s/pages/%s.html", cache_root, str);
		sprintf(page->deps[0], "%s/%s", db_root, "players/");
		sprintf(page->deps[1], "%s/pages/%s", db_root, str);
		page->ndeps = 2;
		page->src = page->deps[1];
	} else if ((str = extract_string_between("/clans/", ".html", path))) {
		page->type = CLANS;
		sprintf(page->dest, "%s/clans/%s.html", cache_root, str);
		sprintf(page->deps[0], "%s/%s", db_root, "players/");
		sprintf(page->deps[1], "%s/clans/%s", db_root, str);
		page->ndeps = 2;
		page->src = page->deps[1];
	} else {
		error(404, "");
	}
}

static int is_cached(struct page *page)
{
	struct stat dest, deps;
	unsigned i;

	if (stat(page->dest, &dest) == -1)
		return 0;
	for (i = 0; i < page->ndeps; i++) {
		if (stat(page->deps[i], &deps) == -1)
			return 0;
		if (deps.st_mtim.tv_sec > dest.st_mtim.tv_sec)
			return 0;
	}

	return 1;
}

static void generate(struct page *page)
{
	int dest, src = -1, err[2];

	assert(page != NULL);

	/*
	 * Page are generated by calling a program who output the page content.
	 *
	 * We need to redirect stdout to the good file.  To handle child's
	 * errors, we need to redirect stderr as well to a pipe so that the
	 * parent can display error.  Finally the script may read data from
	 * stdin and therefor, a redirection may be needed as well.
	 */

	pipe(err);

	/*
	 * Open stdin before fork() because if the file doesn't exist, then we
	 * raise a 404, and if it does but cannot be opened, we raise a 500.
	 */
	if (page->src) {
		if ((src = open(page->src, O_RDONLY)) == -1) {
			if (errno == ENOENT)
				error(404, "");
			else
				error(500, "%s: %s", page->src, strerror(errno));
		}
	}

	/*
	 * Parent process wait for it's child to terminate and dump the
	 * content of the pipe if child's exit status is different than 0.
	 */
	if (fork() > 0) {
		int c;
		FILE *file;

		close(err[1]);
		wait(&c);
		if (WIFEXITED(c) && WEXITSTATUS(c) == EXIT_SUCCESS)
			return;

		error(500, NULL);
		puts("<pre>");
		file = fdopen(err[0], "r");
		while ((c = fgetc(file)) != EOF)
			putchar(c);
		fclose(file);
		puts("</pre>");
		exit(EXIT_FAILURE);
	}

	/* Redirect stderr to the write side of the pipe */
	dup2(err[1], STDERR_FILENO);
	close(err[0]);

	/* Redirect stdin */
	if (page->src) {
		dup2(src, STDIN_FILENO);
		close(src);
	}

	/* Redirect stdout to the cache entry */
	if ((dest = open(page->dest, O_CREAT | O_WRONLY, 0777)) == -1) {
		fprintf(stderr, "%s: %s\n", page->dest, strerror(errno));
		exit(EXIT_FAILURE);
	}
	dup2(dest, STDOUT_FILENO);
	close(dest);

	if (page->type == INDEX)
		execl("./generate_index", "./generate_index", page->deps[0], NULL);
	else if (page->type == PAGES)
		execl("./generate_rank_page", "./generate_rank_page", "full-page", page->deps[0], NULL);
	else if (page->type == CLANS)
		execl("./generate_clan_page", "./generate_clan_page", page->deps[1], page->deps[0], NULL);

	fprintf(stderr, "execl(): %s\n", strerror(errno));
	exit(EXIT_FAILURE);
}

static void print(struct page *page)
{
	FILE *file;
	int c;

	assert(page != NULL);

	if (!(file = fopen(page->dest, "r")))
		error(500, "%s: %s\n", page->dest, strerror(errno));
	printf("Content-Type: text/html\n\n");
	while ((c = fgetc(file)) != EOF)
		putchar(c);
	fclose(file);
}

static void create_cache(void)
{
	static char path[PATH_MAX];
	int ret;

	if ((ret = mkdir(cache_root, 0777)) == -1)
		if (errno != EEXIST)
			error(500, "%s: %s\n", cache_root, strerror(errno));

	sprintf(path, "%s/%s", cache_root, "pages");
	if ((ret = mkdir(path, 0777)) == -1)
		if (errno != EEXIST)
			error(500, "%s: %s\n", path, strerror(errno));

	sprintf(path, "%s/%s", cache_root, "clans");
	if ((ret = mkdir(path, 0777)) == -1)
		if (errno != EEXIST)
			error(500, "%s: %s\n", path, strerror(errno));
}

int main(int argc, char **argv)
{
	struct page page;
	char *path;

	create_cache();

	if (!(path = getenv("DOCUMENT_URI")))
		error(500, "$DOCUMENT_URI not set\n");

	get_page(path, &page);
	if (!is_cached(&page))
		generate(&page);

	print(&page);

	return EXIT_SUCCESS;
}
