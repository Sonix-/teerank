#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <assert.h>
#include <sys/stat.h>
#include <errno.h>
#include <string.h>
#include <limits.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "io.h"
#include "config.h"

static char *reason_phrase(int code)
{
	switch (code) {
	case 200: return "OK";
	case 404: return "Not Found";
	case 500: return "Internal Server Error";
	default:  return "";
	}
}

static void error(int code, char *fmt, ...)
{
	va_list ap;

	printf("Content-type: text/html\n");
	printf("Status: %d %s\n\n", code, reason_phrase(code));
	printf("<h1>%d %s</h1>\n", code, reason_phrase(code));

	if (fmt) {
		printf("<pre>");
		va_start(ap, fmt);
		vprintf(fmt, ap);
		va_end(ap);
		printf("</pre>");
		exit(EXIT_FAILURE);
	}
}

static char *extract_string_between(char *start, char *end, const char *str)
{
	static char ret[MAX_NAME_LENGTH];
	size_t len, len_str, len_start, len_end;

	assert(start != NULL);
	assert(end != NULL);
	assert(str != NULL);

	len_start = strlen(start);
	if (memcmp(str, start, len_start))
		return NULL;
	len_end = strlen(end);
	len_str = strlen(str);
	if (len_end > len_str)
		return NULL;
	if (memcmp(str + len_str - len_end, end, len_end))
		return NULL;
	if (len_start + len_end >= len_str)
		return NULL;
	len = len_str - len_start - len_end;
	memcpy(ret, str + len_start, len);

	return ret;
}

enum type { INDEX, ABOUT, PAGES, CLANS };

struct page {
	enum type type;
	char dest[PATH_MAX];
	unsigned ndeps;
	char deps[16][PATH_MAX];
	char *src;
};

static void get_page(const char *path, struct page *page)
{
	char *str;

	assert(page != NULL);
	assert(page != NULL);

	if (!strcmp(path, "/") || !strcmp(path, "/index.html")) {
		page->type = INDEX;
		sprintf(page->dest, "%s/index.html", config.cache_root);
		sprintf(page->deps[0], "%s/%s", config.root, "players/");
		page->ndeps = 1;
		page->src = NULL;
	} else if (!strcmp(path, "/about.html")) {
		page->type = ABOUT;
		sprintf(page->dest, "%s/about.html", config.cache_root);
		page->ndeps = 0;
		page->src = NULL;
	} else if ((str = extract_string_between("/pages/", ".html", path))) {
		page->type = PAGES;
		sprintf(page->dest, "%s/pages/%s.html", config.cache_root, str);
		sprintf(page->deps[0], "%s/%s", config.root, "players/");
		sprintf(page->deps[1], "%s/pages/%s", config.root, str);
		page->ndeps = 2;
		page->src = page->deps[1];
	} else if ((str = extract_string_between("/clans/", ".html", path))) {
		page->type = CLANS;
		sprintf(page->dest, "%s/clans/%s.html", config.cache_root, str);
		sprintf(page->deps[0], "%s/%s", config.root, "players/");
		sprintf(page->deps[1], "%s/clans/%s", config.root, str);
		page->ndeps = 2;
		page->src = page->deps[1];
	} else {
		error(404, "");
	}
}

static int is_cached(struct page *page)
{
	struct stat dest, deps;
	unsigned i;

	if (stat(page->dest, &dest) == -1)
		return 0;
	for (i = 0; i < page->ndeps; i++) {
		if (stat(page->deps[i], &deps) == -1)
			return 0;
		if (deps.st_mtim.tv_sec > dest.st_mtim.tv_sec)
			return 0;
	}

	return 1;
}

static void generate(struct page *page)
{
	int dest, src = -1, err[2];
	char dest_path[PATH_MAX];

	assert(page != NULL);

	/*
	 * Pages are generated by calling a program that write on stdout the
	 * content of the page.
	 *
	 * The program have to write on stdout, and therefor we need to
	 * redirect stdout.  We redirect it to a temporary file created on
	 * purpose, and then use rename() to move the temporary file to his
	 * proper location in cache.  This is done to avoid any race conditions
	 * when two instances of this CGI generate the same file in cache.
	 *
	 * The program may fail and in this case we return an error 500 and
	 * dump the content of stderr.  For that purpose we need to redirect
	 * stderr to a pipe so that the parent can retrieve errors, if any.
	 *
	 * Eventually, the child may need stdin feeded with some data.
	 */

	if (pipe(err) == -1)
		error(500, "pipe(): %s", strerror(errno));

	/*
	 * Open src before fork() because if the file doesn't exist, then we
	 * raise a 404, and if it does but cannot be opened, we raise a 500.
	 */
	if (page->src) {
		if ((src = open(page->src, O_RDONLY)) == -1) {
			if (errno == ENOENT)
				error(404, "");
			else
				error(500, "%s: %s", page->src, strerror(errno));
		}
	}

	/* The destination file is a temporary file */
	sprintf(dest_path, "%s/tmp-teerank-XXXXXX", config.tmp_root);
	if ((dest = mkstemp(dest_path)) == -1)
		error(500, "mkstemp(): %s", strerror(errno));

	/*
	 * Parent process wait for it's child to terminate and dump the
	 * content of the pipe if child's exit status is different than 0.
	 */
	if (fork() > 0) {
		int c;
		FILE *file;

		close(err[1]);
		wait(&c);
		if (WIFEXITED(c) && WEXITSTATUS(c) == EXIT_SUCCESS) {
			close(dest);
			if (page->src)
				close(src);
			if (rename(dest_path, page->dest) == -1)
				error(500, "rename(%s, %s): %s",
				      dest_path, page->dest, strerror(errno));
			return;
		}

		error(500, NULL);
		puts("<pre>");
		file = fdopen(err[0], "r");
		while ((c = fgetc(file)) != EOF)
			putchar(c);
		fclose(file);
		puts("</pre>");
		exit(EXIT_FAILURE);
	}

	/* Redirect stderr to the write side of the pipe */
	dup2(err[1], STDERR_FILENO);
	close(err[0]);

	/* Redirect stdin */
	if (page->src) {
		dup2(src, STDIN_FILENO);
		close(src);
	}

	/* Redirect stdout to the temporary file */
	dup2(dest, STDOUT_FILENO);
	close(dest);

	/* Eventually, run the program */
	if (page->type == INDEX)
		execl("./teerank-generate-index", "./teerank-generate-index", page->deps[0], NULL);
	else if (page->type == ABOUT)
		execl("./teerank-generate-about", "./teerank-generate-about", NULL);
	else if (page->type == PAGES)
		execl("./teerank-generate-rank-page", "./teerank-generate-rank-page", "full-page", page->deps[0], NULL);
	else if (page->type == CLANS)
		execl("./teerank-generate-clan-page", "./teerank-generate-clan-page", page->deps[1], page->deps[0], NULL);

	fprintf(stderr, "execl(): %s\n", strerror(errno));
	exit(EXIT_FAILURE);
}

static void print(struct page *page)
{
	FILE *file;
	int c;

	assert(page != NULL);

	if (!(file = fopen(page->dest, "r")))
		error(500, "%s: %s\n", page->dest, strerror(errno));
	printf("Content-Type: text/html\n\n");
	while ((c = fgetc(file)) != EOF)
		putchar(c);
	fclose(file);
}

static void create_directory(char *fmt, ...)
{
	va_list ap;
	char path[PATH_MAX];
	int ret;

	va_start(ap, fmt);
	vsprintf(path, fmt, ap);
	va_end(ap);

	if ((ret = mkdir(path, 0777)) == -1)
		if (errno != EEXIST)
			error(500, "%s: %s\n", path, strerror(errno));
}

static void create_cache(void)
{
	create_directory("%s", config.cache_root);
	create_directory("%s/pages", config.cache_root);
	create_directory("%s/clans", config.cache_root);
}

int main(int argc, char **argv)
{
	struct page page;
	char *path;

	load_config();
	create_cache();

	if (!(path = getenv("DOCUMENT_URI")))
		error(500, "$DOCUMENT_URI not set\n");

	get_page(path, &page);
	if (!is_cached(&page))
		generate(&page);

	print(&page);

	return EXIT_SUCCESS;
}
