#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <assert.h>
#include <sys/stat.h>
#include <errno.h>
#include <string.h>
#include <limits.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <dirent.h>

#include "io.h"
#include "config.h"

/*
 * This program can be used as a CGI or as a native program.  What change
 * between both mode is in how errors are reported and how it gets its input.
 */
static enum mode { CGI, NATIVE } mode;

static char *reason_phrase(int code)
{
	switch (code) {
	case 200: return "OK";
	case 404: return "Not Found";
	case 500: return "Internal Server Error";
	default:  return "";
	}
}

static FILE *start_error(int code)
{
	if (mode == CGI) {
		printf("Content-type: text/html\n");
		printf("Status: %d %s\n\n", code, reason_phrase(code));
		printf("<h1>%d %s</h1>\n", code, reason_phrase(code));
		printf("<pre>");
		return stdout;
	}
	return stderr;
}

static void end_error(void)
{
	if (mode == CGI)
		printf("</pre>");
	exit(EXIT_FAILURE);
}

static void error(int code, char *fmt, ...)
{
	va_list ap;
	FILE *file;

	file = start_error(code);
	if (fmt) {
		va_start(ap, fmt);
		vfprintf(file, fmt, ap);
		va_end(ap);
	}
	end_error();
}

#define MAX_PARTS 8
struct url {
	char *path;
	unsigned length;
	char *parts[MAX_PARTS];
};

/*
 * Path is splited by using strtok(), that means '\0' is added where
 * the separator is.  We provide unsplit() that does remove those '\0'
 * so the path can be used in full, again.
 */
static void split(char *path, struct url *url)
{
	char *tmp;

	assert(path != NULL);
	assert(url != NULL);

	if (*path++ != '/')
		error(404, "Path should begin with '/'\n");

	url->path = path;
	url->length = 0;
	tmp = strtok(path, "/");
	do {
		if (url->length == MAX_PARTS)
			error(404, "Path contains too much components\n");
		url->parts[url->length++] = tmp;
	} while ((tmp = strtok(NULL, "/")));
}

static char *unsplit(struct url *url)
{
	unsigned i;
	for (i = 1; i < url->length; i++)
		url->parts[i][-1] = '/';
	return url->path;
}

static int is_cached(char *path, char *dep)
{
	struct stat statpath, statdep;

	assert(path != NULL);

	if (!dep)
		return 0;
	if (stat(path, &statpath) == -1)
		return 0;
	if (stat(dep, &statdep) == -1)
		return 0;
	if (statdep.st_mtim.tv_sec > statpath.st_mtim.tv_sec)
		return 0;

	return 1;
}

/*
 * srcname and destname should be relative to respectively the database and
 * the cache.
 */
static void generate_file(char **args, char *srcname, char *destname)
{
	int dest, src = -1, err[2];
	char tmpname[PATH_MAX], srcpath[PATH_MAX], destpath[PATH_MAX];

	assert(destname != NULL);

	/*
	 * Files are generated by calling a program that write on stdout the
	 * content of the page.
	 *
	 * The program have to write on stdout, and therefor we need to
	 * redirect stdout.  We redirect it to a temporary file created on
	 * purpose, and then use rename() to move the temporary file to his
	 * proper location in cache.  This is done to avoid any race conditions
	 * when two instances of this CGI generate the same file in cache.
	 *
	 * The program may fail and in this case we return an error 500 and
	 * dump the content of stderr.  For that purpose we need to redirect
	 * stderr to a pipe so that the parent can retrieve errors, if any.
	 *
	 * Eventually, the child may need stdin feeded with some data.
	 */

	/*
	 * Open src before fork() because if the file doesn't exist, then we
	 * raise a 404, and if it does but cannot be opened, we raise a 500.
	 */
	if (srcname) {
		sprintf(srcpath, "%s/%s", config.root, srcname);
		if ((src = open(srcpath, O_RDONLY)) == -1) {
			if (errno == ENOENT)
				error(404, "%s: Doesn't exist\n", srcname);
			else
				error(500, "%s: %s\n", srcpath, strerror(errno));
		}
	}

	/* Do not generate if is already cached */
	sprintf(destpath, "%s/%s", config.cache_root, destname);
	if (is_cached(destpath, srcname ? srcpath : NULL))
		return;

	/* The destination file is a temporary file */
	sprintf(tmpname, "%s/tmp-teerank-XXXXXX", config.tmp_root);
	if ((dest = mkstemp(tmpname)) == -1)
		error(500, "mkstemp(): %s\n", strerror(errno));

	if (pipe(err) == -1)
		error(500, "pipe(): %s\n", strerror(errno));

	/*
	 * Parent process wait for it's child to terminate and dump the
	 * content of the pipe if child's exit status is different than 0.
	 */
	if (fork() > 0) {
		int c;
		FILE *file, *errfile;

		close(err[1]);
		close(dest);
		if (srcname)
			close(src);

		wait(&c);
		if (WIFEXITED(c) && WEXITSTATUS(c) == EXIT_SUCCESS) {
			if (rename(tmpname, destpath) == -1)
				error(500, "rename(%s, %s): %s\n",
				      tmpname, destpath, strerror(errno));
			return;
		}

		/* Report error */
		errfile = start_error(500);
		fprintf(errfile, "%s: ", args[0]);
		file = fdopen(err[0], "r");
		while ((c = fgetc(file)) != EOF)
			fputc(c, errfile);
		fclose(file);
		end_error();
	}

	/* Redirect stderr to the write side of the pipe */
	dup2(err[1], STDERR_FILENO);
	close(err[0]);

	/* Redirect stdin */
	if (srcname) {
		dup2(src, STDIN_FILENO);
		close(src);
	}

	/* Redirect stdout to the temporary file */
	dup2(dest, STDOUT_FILENO);
	close(dest);

	/* Eventually, run the program */
	execvp(args[0], args);
	fprintf(stderr, "execvp(%s): %s\n", args[0], strerror(errno));
	exit(EXIT_FAILURE);
}

/*
 * Based on the implicit assertion that HTML pages tree have the same layout
 * than the database.  So for example, /clans/1 in database correspond to
 * /clans/1.html in pages tree.
 *
 * The filename parameter must point to an entry in args.  If it is not NULL,
 * then it will contain the current filename.
 */
static void generate_foreach(char *pathname, char **args, char **filename)
{
	DIR *dir;
	struct dirent *dp;
	char src[PATH_MAX], dest[PATH_MAX], path[PATH_MAX];

	assert(pathname != NULL);

	sprintf(path, "%s/%s", config.root, pathname);
	if (!(dir = opendir(path)))
		error(500, "%s: %s\n", path, strerror(errno));
	while ((dp = readdir(dir))) {
		if (!strcmp(dp->d_name, ".") || !strcmp(dp->d_name, ".."))
			continue;

		sprintf(src,  "%s/%s",      pathname, dp->d_name);
		sprintf(dest, "%s/%s.html", pathname, dp->d_name);

		if (filename)
			*filename = dp->d_name;

		generate_file(args, src, dest);
	}
	closedir(dir);
}

static void generate(char *path)
{
	char **p;
	struct url url;

	split(path, &url);
	p = url.parts;

	if (!strcmp(p[0], "index.html")) {
		generate_file((char*[]){ "teerank-generate-index", NULL },
		              NULL, unsplit(&url));

	} else if (!strcmp(p[0], "about.html")) {
		generate_file((char*[]){ "teerank-generate-about", NULL },
		              NULL, unsplit(&url));

	} else if (!strcmp(p[0], "pages")) {
		char *args[] = { "teerank-generate-rank-page", "full-page", NULL };
		if (url.length == 1)
			generate_foreach(unsplit(&url), args, NULL);
		else if (url.length == 2)
			generate_file(args, NULL, unsplit(&url));

	} else if (!strcmp(p[0], "clans")) {
		char *args[] = { "teerank-generate-clan-page", p[2], NULL };
		if (url.length == 1)
			generate_foreach(unsplit(&url), args, &args[1]);
		else if (url.length == 2)
			generate_file(args, NULL, unsplit(&url));
	} else {
		error(404, "%s: Doesn't exist\n", unsplit(&url));
	}
}

static void print(const char *name)
{
	FILE *file;
	int c;
	char path[PATH_MAX];

	assert(name != NULL);

	sprintf(path, "%s/%s", config.cache_root, name);
	if (!(file = fopen(path, "r")))
		error(500, "%s: %s\n", path, strerror(errno));
	printf("Content-Type: text/html\n\n");
	while ((c = fgetc(file)) != EOF)
		putchar(c);
	fclose(file);
}

static void create_directory(char *fmt, ...)
{
	va_list ap;
	char path[PATH_MAX];
	int ret;

	va_start(ap, fmt);
	vsprintf(path, fmt, ap);
	va_end(ap);

	if ((ret = mkdir(path, 0777)) == -1)
		if (errno != EEXIST)
			error(500, "%s: %s\n", path, strerror(errno));
}

static void init_cache(void)
{
	create_directory("%s", config.cache_root);
	create_directory("%s/pages", config.cache_root);
	create_directory("%s/clans", config.cache_root);
}

int main(int argc, char **argv)
{
	load_config();
	init_cache();

	/* No arguments on the command line means it is used as a CGI */
	if (argc > 1) {
		mode = NATIVE;
		while (*++argv)
			generate(*argv);
	} else {
		char *path = getenv("DOCUMENT_URI");

		mode = CGI;
		if (!path)
			error(500, "$DOCUMENT_URI not set\n");

		generate(path);
		print(path);
	}

	return EXIT_SUCCESS;
}
